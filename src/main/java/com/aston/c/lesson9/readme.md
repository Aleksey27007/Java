-------------------
### SOLID
### Паттерны проектирования.

--------------------

▎Конспект по принципам SOLID и паттернам проектирования

---

▎Принципы SOLID

SOLID — это акроним, обозначающий пять основных принципов объектно-ориентированного проектирования, которые помогают создавать гибкие и поддерживаемые программные системы.

1. S - Single Responsibility Principle (SRP)  
   Каждый класс должен иметь одну и только одну ответственность. Это означает, что класс должен быть сосредоточен на выполнении одной задачи или функции.

2. O - Open/Closed Principle (OCP)  
   Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации. Это позволяет добавлять новую функциональность без изменения существующего кода.

3. L - Liskov Substitution Principle (LSP)  
   Объекты подклассов должны быть взаимозаменяемыми с объектами базового класса без изменения правильности работы программы. Это означает, что подклассы должны сохранять поведение базового класса.

4. I - Interface Segregation Principle (ISP)  
   Клиенты не должны зависеть от интерфейсов, которые они не используют. Это предполагает создание специализированных интерфейсов вместо одного общего.

5. D - Dependency Inversion Principle (DIP)  
   Модули высшего уровня не должны зависеть от модулей низшего уровня. Оба типа модулей должны зависеть от абстракций (интерфейсов). Это уменьшает связанность между компонентами системы.

---

▎Паттерны проектирования

Паттерны проектирования — это общепринятые решения для распространенных задач проектирования программного обеспечения. Они делятся на три основные категории:

1. Паттерны создания (Creational Patterns)

   • Singleton: Гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к нему.

   • Factory Method: Определяет интерфейс для создания объектов, позволяя подклассам изменять тип создаваемых объектов.

   • Abstract Factory: Предоставляет интерфейс для создания семейств связанных или зависимых объектов без указания их конкретных классов.

   • Builder: Разделяет конструкцию сложного объекта на отдельные шаги, позволяя создавать различные представления объекта.

   • Prototype: Позволяет копировать объекты, не вдаваясь в детали их реализации.

2. Структурные паттерны (Structural Patterns)

   • Adapter: Позволяет объектам с несовместимыми интерфейсами работать вместе.

   • Decorator: Позволяет динамически добавлять новое поведение к объекту, оборачивая его в другой объект.

   • Facade: Предоставляет упрощенный интерфейс к более сложной системе классов.

   • Composite: Позволяет сгруппировать объекты в древовидную структуру для представления иерархий "часть-целое".

   • Proxy: Предоставляет суррогат или заместитель для другого объекта, чтобы контролировать доступ к нему.

3. Поведенческие паттерны (Behavioral Patterns)

   • Observer: Определяет зависимость "один ко многим" между объектами, так что при изменении состояния одного объекта все зависимые объекты уведомляются и обновляются автоматически.

   • Strategy: Определяет семейство алгоритмов, инкапсулирует их и делает их взаимозаменяемыми.

   • Command: Инкапсулирует запрос как объект, позволяя параметризовать клиентов с различными запросами.

   • Iterator: Предоставляет способ последовательного доступа к элементам агрегированного объекта без раскрытия его внутреннего представления.

   • State: Позволяет объекту изменять свое поведение в зависимости от его внутреннего состояния.