---------------------------
### Многопоточность
### Способы создания потоков
### Виды состояния потоков
### Ключевое слово volatile
### Проблемы многопоточных приложений: состояние гонки,  дедлоки и лайфлоки
### Пакет java.util.concurrent
### Atomic
### Lock
### Executors
### Future, CompletableFuture
### Синхронизаторы

---------------------------
▎1. Многопоточность

Определение: Многопоточность — это возможность выполнения нескольких потоков (нитей) одновременно, что позволяет программе выполнять несколько операций параллельно, повышая ее производительность и отзывчивость.

▎2. Способы создания потоков

В Java существует два основных способа создания потоков:

1. Наследование от класса Thread:

   • Создайте класс, который наследует Thread.

   • Переопределите метод run().

   • Создайте экземпляр этого класса и вызовите метод start().

   Пример:

   >class MyThread extends Thread {
   > 
   >   public void run() {
   > 
   >      System.out.println("Поток запущен!");
   >   }
   > 
   >}
>
   >public class Main {
> 
   >   public static void main(String[] args) {
> 
   >      MyThread thread = new MyThread();
   >      thread.start();
   >   }
> 
   >}

2. Реализация интерфейса Runnable:

   • Создайте класс, который реализует интерфейс Runnable.

   • Реализуйте метод run().

   • Создайте экземпляр Thread, передав объект Runnable, и вызовите метод start().

   Пример:
   >class MyRunnable implements Runnable {
   > 
   >public void run() {
   > 
   >System.out.println("Поток запущен!");
   > 
   >}
   > 
   >}
>
   >public class Main {
> 
   >public static void main(String[] args) {
> 
   >Thread thread = new Thread(new MyRunnable());
> 
   >thread.start();
> 
   >}
> 
   >}


▎3. Виды состояния потоков

Потоки в Java могут находиться в следующих состояниях:

1. Новый (New): Поток создан, но еще не запущен.

2. Исполняющийся (Runnable): Поток готов к выполнению и ожидает выделения процессорного времени.

3. Ожидание (Waiting): Поток ожидает, пока другой поток завершит свою работу или уведомит его.

4. Блокировка (Blocked): Поток ожидает освобождения ресурса (например, синхронизированного блока).

5. Завершенный (Terminated): Поток завершил свою работу.

▎4. Ключевое слово volatile

Определение: Ключевое слово volatile используется для объявления переменной, значение которой может изменяться несколькими потоками. Оно гарантирует, что изменения, внесенные одним потоком, будут видны другим потокам.

Пример:

    class Example {
       private volatile boolean flag = false;
   
       public void setFlag() {
           flag = true;
       }
   
       public boolean isFlag() {
           return flag;
       }
    }


▎5. Проблемы многопоточных приложений

1. Состояние гонки (Race Condition): Происходит, когда два или более потока пытаются одновременно изменить данные, что может привести к непредсказуемым результатам.

2. Дедлоки (Deadlock): Состояние, когда два или более потоков ждут друг друга, чтобы освободить ресурсы, и ни один из них не может продолжить выполнение.

3. Лайфлоки (Livelock): Состояние, когда потоки продолжают изменять свое состояние, но не могут завершить выполнение из-за постоянного изменения.

▎6. Пакет java.util.concurrent

Этот пакет предоставляет высокоуровневые инструменты для работы с многопоточностью:

• Пулы потоков (Thread Pools): Управляют группами потоков для повторного использования.

• Синхронизаторы: Обеспечивают механизмы синхронизации между потоками.

▎7. Atomic

Классы в пакете java.util.concurrent.atomic обеспечивают атомарные операции над переменными без использования блокировок. Примеры:

• AtomicInteger

• AtomicBoolean

• AtomicReference

Пример использования AtomicInteger:

    import java.util.concurrent.atomic.AtomicInteger;
    
    class Counter {
    private AtomicInteger count = new AtomicInteger(0);

       public void increment() {
           count.incrementAndGet();
       }
   
       public int getCount() {
           return count.get();
       }
    }


▎8. Lock

Интерфейс Lock предоставляет более гибкие механизмы управления блокировками по сравнению с синхронизацией с помощью ключевого слова synchronized. Основные реализации:

• ReentrantLock: Позволяет повторное захватывание блокировки.

• ReadWriteLock: Разделяет блокировки на чтение и запись.

Пример использования ReentrantLock:

    import java.util.concurrent.locks.ReentrantLock;
    
    class Counter {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

        public void increment() {
            lock.lock();
            try {
                count++;
            } finally {
                lock.unlock();
            }
        }
    
        public int getCount() {
            return count;
        }
    }


▎9. Executors

Executors — это фреймворк для управления пулами потоков. Он упрощает создание и управление потоками.

Примеры создания пула потоков:
>ExecutorService executor = Executors.newFixedThreadPool(10);
> 
>executor.submit(() -> {
> 
>// Задача
> 
>});
> 
>executor.shutdown();


▎10. Future и CompletableFuture

• Future: Интерфейс, представляющий результат асинхронной операции. Позволяет получить результат выполнения задачи или обработать исключение.

Пример использования Future:
>ExecutorService executor = Executors.newCachedThreadPool();
> 
>Future<Integer> future = executor.submit(() -> {
> 
>// Долгая задача
> 
>return 42;
> 
>});
> 
>try {
> 
>Integer result = future.get(); // Блокирует до получения результата
> 
>} catch (InterruptedException | ExecutionException e) {
> 
>e.printStackTrace();
> 
>}


• CompletableFuture: Расширяет возможности Future, позволяя создавать асинхронные цепочки задач и обрабатывать результаты более гибко.

Пример использования CompletableFuture:

>CompletableFuture.supplyAsync(() -> {
> 
>// Долгая задача
> 
>return 42;
> 
>}).thenAccept(result -> {
> 
>System.out.println("Результат: " + result);
> 
>});


▎11. Синхронизаторы

Синхронизаторы — это механизмы, которые помогают управлять доступом к общим ресурсам в многопоточной среде. Основные синхронизаторы:

• CountDownLatch: Позволяет одному или нескольким потокам ждать завершения определенного количества операций.


• CyclicBarrier: Позволяет группе потоков ожидать друг друга на определенной точке выполнения.

• Semaphore: Ограничивает количество потоков, которые могут одновременно получить доступ к ресурсу.

• Exchanger: Позволяет двум потокам обмениваться данными.

▎Заключение

Многопоточность в Java — это мощный инструмент для повышения производительности приложений. Понимание различных аспектов многопоточности, таких как создание потоков, управление состоянием и синхронизация, поможет разработчикам создавать более эффективные и надежные программы.