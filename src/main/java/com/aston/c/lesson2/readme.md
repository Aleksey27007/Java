# Занятие 1

-----------------------------

### Абстрактные классы и интерфейсы(отличия, где что лучше использовать)
### Изменяемые и неизменяемые объекты(примеры неизменяемых классов в java, как сделать класс неизменяемым)
### Inner и Nested классы
### Локальные и анонимные классы

------------------------------
### Абстрактные классы и интерфейсы(отличия, где что лучше использовать)

В Java абстрактные классы и интерфейсы используются для определения общего поведения, но у них есть важные отличия и особенности применения. Давайте рассмотрим их подробнее.

▎Абстрактные классы

1. Определение: Абстрактный класс — это класс, который не может быть инстанцирован и может содержать как абстрактные методы (без реализации), так и методы с реализацией.

2. Синтаксис:

   >abstract class Animal {
     >>abstract void makeSound();
   > 
   >    void eat() {
   >>        System.out.println("Eating...");
   >    }
   > 
   >  }

3. Наследование: Класс может наследовать только один абстрактный класс (Java поддерживает одиночное наследование).

4. Состояние: Абстрактный класс может иметь поля (переменные экземпляра) и конструкторы.

5. Использование:

   • Когда нужно создать базовый класс с некоторой общей реализацией.

   • Когда необходимо использовать общие поля или методы.

   • Когда требуется контролировать доступ к методам через модификаторы доступа.

▎Интерфейсы

1. Определение: Интерфейс — это контракт, который определяет набор методов, которые должны быть реализованы классами, которые его используют. Все методы в интерфейсе по умолчанию являются абстрактными (до Java 8) и публичными.

2. Синтаксис:

   >interface Animal {
   >>void makeSound();
   > 
   >}


3. Наследование: Класс может реализовывать несколько интерфейсов (Java поддерживает множественное наследование через интерфейсы).

4. Состояние: Интерфейсы не могут иметь полей (но могут иметь статические финальные переменные) и не могут содержать конструкторы.

5. Использование:

   • Когда необходимо определить поведение, которое могут реализовать различные классы.

   • Когда нужно обеспечить возможность множественного наследования.

   • Когда нужно создать API, который будет использоваться различными классами.

▎Когда что использовать

• Используйте абстрактные классы, когда:

• У вас есть общий код, который нужно переиспользовать.

• Вы хотите контролировать состояние объектов с помощью полей и методов.

• Вы хотите обеспечить некоторую реализацию по умолчанию для методов.

• Используйте интерфейсы, когда:

• Вы хотите определить поведение, которое могут реализовать разные классы, независимо от их положения в иерархии наследования.

• Вам нужно поддерживать множественное наследование.

• Вы создаете API или библиотеку, где важно, чтобы пользователи могли легко расширять функциональность.

▎Пример использования

// Абстрактный класс
   >abstract class Vehicle {
   >>abstract void start();
   >
>> void stop() {
   >>>    System.out.println("Vehicle stopped.");
   >>
>> }
   > 
   >}

// Интерфейс
interface Drivable {
void drive();
}

// Конкретный класс, который наследует абстрактный класс и реализует интерфейс
>class Car extends Vehicle implements Drivable {
>>@Override
>> 
>>void start() {
>>>System.out.println("Car started.");
>> 
>>}
>
>>@Override
>> 
>>public void drive() {
>>>System.out.println("Car is driving.");
>> 
>>}
> 
>}


В этом примере Car наследует функциональность от Vehicle и реализует поведение из интерфейса Drivable.

------------------
### Изменяемые и неизменяемые объекты(примеры неизменяемых классов в java, как сделать класс неизменяемым)

В Java объекты могут быть изменяемыми (mutable) и неизменяемыми (immutable). Изменяемые объекты позволяют изменять свое состояние после создания, тогда как неизменяемые объекты не могут изменять свое состояние после инициализации. Неизменяемые объекты имеют несколько преимуществ, таких как потокобезопасность и простота использования.

▎Примеры неизменяемых классов в Java

1. Класс String: Это один из самых известных примеров неизменяемого класса в Java. После создания объекта String его значение не может быть изменено.


String str = "Hello";
str.concat(" World"); // Это не изменяет str, а создает новый объект String


2. Класс Integer, Double и другие обертки: Все классы-обертки для примитивных типов также являются неизменяемыми.

3. Класс LocalDate из пакета java.time: Этот класс представляет дату и также является неизменяемым.

▎Как сделать класс неизменяемым

Чтобы создать неизменяемый класс в Java, следуйте этим рекомендациям:

1. Объявите класс как final: Это предотвратит наследование от вашего класса, что может привести к изменению его состояния.


        public final class ImmutablePoint {
        // Поля должны быть private и final
            private final int x;
            private final int y;
        
               public ImmutablePoint(int x, int y) {
                   this.x = x;
                   this.y = y;
               }
        
               public int getX() {
                   return x;
               }
        
               public int getY() {
                return y;
                }
        }


2. Сделайте все поля private и final: Это гарантирует, что поля могут быть инициализированы только один раз, и их значение не может быть изменено.

3. Не предоставляйте методы, которые изменяют состояние объекта: Избегайте методов, которые могли бы изменить значения полей.

4. Если поля являются ссылочными типами, возвращайте их копии: Если ваше поле — это объект, который может изменяться (например, массив или список), возвращайте его копию вместо ссылки на оригинальный объект.


    public final class ImmutableList {
        private final List<String> items;
        
               public ImmutableList(List<String> items) {
                   // Создаем копию списка
                   this.items = new ArrayList<>(items);
               }
        
               public List<String> getItems() {
                   // Возвращаем копию списка
                   return new ArrayList<>(items);
               }
    }


▎Пример неизменяемого класса

Вот полный пример неизменяемого класса:

    import java.util.Objects;

    public final class ImmutablePerson {
    
        private final String name;
        
        private final int age;
    
            public ImmutablePerson(String name, int age) {
                this.name = Objects.requireNonNull(name); // Проверка на null
                this.age = age;
            }
        
            public String getName() {
                return name;
            }
        
            public int getAge() {
                return age;
            }
        
            @Override
            public String toString() {
                return "ImmutablePerson{" +
                        "name='" + name + ''' +
                        ", age=" + age +
                        '}';
            }
    }


▎Заключение

Неизменяемые классы в Java упрощают работу с объектами, делают код более безопасным и предсказуемым. Следуя описанным принципам, вы можете создать свои собственные неизменяемые классы для различных нужд в приложении.

------------------

### Inner и Nested классы

В Java внутренние (inner) и вложенные (nested) классы — это классы, которые определены внутри другого класса. Они позволяют организовывать код более структурированно и логично. Давайте рассмотрим их подробнее.

▎Вложенные классы (Nested Classes)

Вложенные классы делятся на два типа:

1. Статические вложенные классы (Static Nested Classes):

   • Они объявляются с ключевым словом static.

   • Не имеют доступа к нестатическим членам внешнего класса (т.е. к полям и методам, которые не являются статическими).

   • Могут обращаться только к статическим членам внешнего класса.

   Пример:


    public class OuterClass {
        private static String staticOuterField = "Static Outer Field";
    
           static class StaticNestedClass {
               void display() {
                   System.out.println(staticOuterField); // Доступ к статическому полю внешнего класса
               }
           }
    }

    public class Main {
        public static void main(String[] args) {
            OuterClass.StaticNestedClass nested = new OuterClass.StaticNestedClass();
            nested.display();
        }
    }


2. Нестатические вложенные классы (Inner Classes):

   • Они не объявляются с ключевым словом static.

   • Имеют доступ ко всем членам внешнего класса, включая нестатические.

   • Создаются в контексте экземпляра внешнего класса.

   Пример:


    public class OuterClass {
        private String outerField = "Outer Field";

        class InnerClass {
           void display() {
               System.out.println(outerField); // Доступ к нестатическому полю внешнего класса
           }
        }
    }

    public class Main {
        public static void main(String[] args) {
            OuterClass outer = new OuterClass();
            OuterClass.InnerClass inner = outer.new InnerClass(); // Создание экземпляра внутреннего класса
            inner.display();
        }
    }


▎Анонимные классы

Анонимные классы — это особый вид вложенных классов, которые не имеют имени. Они обычно используются для создания экземпляров интерфейсов или абстрактных классов на месте, когда требуется переопределить методы.

Пример:

    public class Main {
        public static void main(String[] args) {
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    System.out.println("Running in an anonymous class");
                }
            };
        
            Thread thread = new Thread(runnable);
            thread.start();
        }
    }


▎Подводя итоги

• Вложенные классы — это классы, определенные внутри другого класса. Они могут быть статическими или нестатическими.

• Статические вложенные классы могут обращаться только к статическим членам внешнего класса.

• Нестатические вложенные классы имеют доступ ко всем членам внешнего класса, включая нестатические.

• Анонимные классы позволяют создавать временные реализации интерфейсов или абстрактных классов без явного определения нового класса.

Использование внутренних и вложенных классов помогает организовать код и улучшить его читаемость, особенно когда класс имеет смысл только в контексте другого класса.

------------------
### Локальные и анонимные классы

Локальные и анонимные классы в Java — это два типа вложенных классов, которые позволяют создавать классы внутри методов. Они имеют свои особенности и используются в разных ситуациях. Давайте рассмотрим их подробнее.

▎Локальные классы

Локальные классы определяются внутри метода и могут использоваться только в этом методе. Они могут обращаться к переменным метода, если эти переменные объявлены как final или являются эффективно финальными (т.е. не изменяются после инициализации).

▎Пример локального класса:

    public class OuterClass {
        void outerMethod() {
            final String localVariable = "Hello from local variable";

            class LocalClass {
                void display() {
                    System.out.println(localVariable); // Доступ к локальной переменной
                }
            }
    
            LocalClass localClass = new LocalClass();
            localClass.display();
        }
    }

    public class Main {
        public static void main(String[] args) {
            OuterClass outer = new OuterClass();
            outer.outerMethod();
        }
    }



▎Анонимные классы

Анонимные классы — это классы без имени, которые создаются на месте. Они обычно используются для реализации интерфейсов или абстрактных классов, когда требуется переопределить методы. Анонимные классы могут обращаться к переменным из внешнего метода, но только если эти переменные являются final или эффективными финальными.

▎Пример анонимного класса:

    public class Main {
        public static void main(String[] args) {
        final String greeting = "Hello from anonymous class";

            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    System.out.println(greeting); // Доступ к локальной переменной
                }
            };
    
            Thread thread = new Thread(runnable);
            thread.start();
        }
    }


▎Основные отличия

1. Определение:

   • Локальные классы имеют имя и могут быть объявлены внутри метода.

   • Анонимные классы не имеют имени и создаются на месте.

2. Использование:

   • Локальные классы могут быть использованы многократно в пределах метода, если они объявлены перед их использованием.

   • Анонимные классы создаются и используются сразу при объявлении.

3. Сложность:

   • Локальные классы могут содержать поля и методы, как обычные классы.

   • Анонимные классы могут содержать только переопределенные методы.

▎Когда использовать

• Локальные классы полезны, когда вам нужно создать класс с несколькими методами или полями, и вы хотите, чтобы он был доступен только в пределах метода.

• Анонимные классы удобны для быстрого создания одноразовых реализаций интерфейсов или абстрактных классов, особенно когда вам нужно переопределить всего один или два метода.

Оба типа классов помогают улучшить читаемость кода и его структуру, позволяя создавать более компактные и организованные решения.

------------------