------------------------------
### Алгоритмы
### Big O notation(какие виды временной сложности алгоритмов бывают)
### Виды сортировок(отличие quicksort от merge sort)
### Generics
### Коллекции
### Иерархия коллекций
### List
### Set
### Map
### Временная сложность для разных операций разных коллекций
### Неизменяемые коллекции(создание с помощью List.of(), методы класса Collections)
### LinkedHashMap, TreeMap
### Интерфейсы Comparable и Comparator

------------------------------

▎Алгоритмы

• Алгоритм — это последовательность шагов для решения задачи или выполнения вычислений.

------------------------------
▎Big O Notation

• Big O Notation — способ описания временной сложности алгоритма в зависимости от размера входных данных.

• Основные виды временной сложности:

• O(1): Константная сложность — время выполнения не зависит от размера входных данных.

• O(log n): Логарифмическая сложность — время выполнения увеличивается логарифмически при увеличении входных данных (например, бинарный поиск).

• O(n): Линейная сложность — время выполнения пропорционально размеру входных данных.

• O(n log n): Линейно-логарифмическая сложность — характерно для эффективных сортировок (например, Merge Sort).

• O(n²): Квадратичная сложность — время выполнения пропорционально квадрату размера входных данных (например, сортировка пузырьком).

• O(2^n): Экспоненциальная сложность — время выполнения удваивается с каждым добавлением элемента (например, решение задачи о рюкзаке с полным перебором).

• O(n!): Факториальная сложность — очень высокая сложность, характерная для задач, связанных с перестановками.

------------------------------
▎Виды сортировок

• Quicksort:

• Разделяй и властвуй: выбирается опорный элемент, массив разбивается на подмассивы, которые сортируются рекурсивно.

• Средняя временная сложность: O(n log n), худшая — O(n²) (в случае уже отсортированного массива).

• Преимущества: часто быстрее на практике из-за меньшего количества операций по сравнению с другими алгоритмами.

• Merge Sort:

• Также использует метод разделяй и властвуй: массив делится на две половины, каждая из которых сортируется рекурсивно, затем происходит слияние.

• Временная сложность: O(n log n) в лучшем, среднем и худшем случаях.

• Преимущества: стабильный алгоритм (сохраняет порядок равных элементов), хорошо работает на больших объемах данных.

------------------------------
▎Generics

• Generics в Java позволяют создавать классы, интерфейсы и методы с параметризованными типами.

• Позволяют писать обобщенный код, который может работать с различными типами данных.

• Преимущества:

• Повышение безопасности типов (отсутствие необходимости приведения типов).

• Уменьшение дублирования кода.

------------------------------
▎Коллекции

• Коллекции в Java представляют собой структуры данных для хранения и обработки групп объектов.

------------------------------
▎Иерархия коллекций

• Основные интерфейсы коллекций:

• Collection: корневой интерфейс для всех коллекций.

    • List: упорядоченная коллекция, допускающая дубликаты. Примеры: ArrayList, LinkedList.

    • Set: коллекция, не допускающая дубликатов. Примеры: HashSet, TreeSet.

    • Map: коллекция пар "ключ-значение". Примеры: HashMap, TreeMap.

------------------------------
▎Временная сложность для разных операций разных коллекций

### ArrayList:

• Добавление в конец: O(1) (амортизированное).

• Вставка/удаление по индексу: O(n).

• Поиск по индексу: O(1).

### LinkedList:

• Добавление/удаление в начале/конце: O(1).

• Вставка/удаление по индексу: O(n).

• Поиск по индексу: O(n).

### HashSet:

• Добавление/удаление/поиск: O(1) (в среднем).

### TreeSet:

• Добавление/удаление/поиск: O(log n).

### HashMap:

• Добавление/удаление/поиск по ключу: O(1) (в среднем).

### TreeMap:

• Добавление/удаление/поиск по ключу: O(log n).

------------------------------
▎Неизменяемые коллекции

• Создание неизменяемых списков с помощью List.of(), например:

>List<String> immutableList = List.of("A", "B", "C");


• Методы класса Collections для создания неизменяемых коллекций:

>List<String> unmodifiableList = Collections.unmodifiableList(originalList);


------------------------------
▎LinkedHashMap и TreeMap

### LinkedHashMap:

• Хранит порядок вставки элементов.

• Позволяет итерацию в порядке добавления элементов.

### TreeMap:

• Реализует интерфейс NavigableMap, хранит элементы в отсортированном порядке по ключу.

• Сложность операций O(log n).

------------------------------
▎Интерфейсы Comparable и Comparator

### Comparable:

• Используется для естественного порядка объектов. Класс реализует метод compareTo(T o).

• Пример:

    public class Person implements Comparable<Person> {
        private String name;
        public int compareTo(Person other) {
            return this.name.compareTo(other.name);
        }
    }


### Comparator:

• Используется для определения порядка объектов вне их класса. Реализует метод compare(T o1, T o2).

• Пример:

    public class PersonComparator implements Comparator<Person> {
        public int compare(Person p1, Person p2) {
            return p1.getName().compareTo(p2.getName());
        }
    }
    